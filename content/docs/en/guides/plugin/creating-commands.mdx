---
title: "Creating Commands"
description: "Learn how to create custom commands for your Hytale mod."
authors:
    - name: "Neil Revin"
      url: "https://itsneil.dev"
    - name: "oskarscot"
      url: "https://oskar.scot"
    - name: "jacobwojoski"
      url: "https://github.com/jacobwojoski"
---

In this guide, you will learn how to create custom commands for your Hytale mod.
You can see information on the following topics:
- Command types
    - AbstractAsyncCommand
    - AbstractPlayerCommand
    - AbstractTargetPlayerCommand
    - AbstractTargetEntityCommand
- Arguments 
- Argument Validators
- Permissions
- Command Variants
- Subcommands

## The `AbstractAsyncCommand` Class
The most basic command is an `AbstractAsyncCommand`. Unlike the other commands AbstractAsyncCommand's ececute funtion is called `executeAsync` and returns a `completeableFuture`

*WARN* `AbstractAsyncCommand` runs on its own background thread. This means it is not tied to any world instance. Because of this it can not edit any Stores or Refs without getting the desired world first as the world needs to ececute the command in its thread. To access this data any of the other command types would be prefered and are likely what you will want to use instead.

The main purpose for a command like this would be for something that can happen everywhere and is not tied to a specific world. For example a `serverRules` command to tell the user thats running the command what are the servers rules are nomatter what world they are in.

```java
// Command that can be run that lists the server rules in chat to the player
public class ServerRulesCommand extends AbstractAsyncCommand {

    // Constructor
    public ServerRulesCommand() {
        // Pass any needed info to AbstractAsyncCommand
        // super(<The command>, <Command description>)
        super("rules", "Lists the servers rules");
    }

    // Run the command
    // arg1: conetext - info about who ran the command. Server console?, Some player? 
    @Override
    protected CompleteableFuture<Void> executeAsync(CommandContext context) {
        context.sendMessage(Message.raw("The only rule is there are no rules"));
        return CompleteableFuture.completedFuture(null);
    }
}
```

*NOTE:* Remember to add the command to the command registry in your main plugin class.
```java
public class TutorialCommandsPlugin extends JavaPlugin {
    public TutorialCommandsPlugin(@Nonnull JavaPluginInit) { super(init); }

    
    @Override
    protected void setup() {
        CommandRegistry registry = getCommandRegistry()

        // ServerRulesCommand - List rules for the server
        // Usage: /rules
        commandRegistry.registerCommand(new ServerRulesCommand())
    }
}
```
---

## The `AbstractPlayerCommand` Class

To create a command, you can extend the `AbstractPlayerCommand` class. You need to provide a constructor that calls the `BaseCommand` constructor with the command name, description, and whether the command requires confirmation (--confirm while running the command).

You can override the `execute` function to implement the command's behavior. It gives you access to the CommandContext which is always a player in this case, the EntityStore, the Reference store, the player reference as well as the World in which the command is being executed.
It's important to know that `AbstractPlayerCommand` extends `AbstractAsyncCommand` meaning that commands do not execute on the main server thread. 

You can use the `Store` along with the `Ref` to access all entity components like the `Player` component, `UUIDComponent` or `TransformComponent`.

For more information about Hytale's Entity Component System visit the [Hytale ECS Theory](https://hytalemodding.dev/en/docs/guides/ecs/hytale-ecs-theory) guide.


```java
public class ExampleCommand extends AbstractPlayerCommand {

  public ExampleCommand() {
    super("test", "Super test command!");
  }

  @Override
  protected void execute(@Nonnull CommandContext commandContext, @Nonnull Store<EntityStore> store, @Nonnull Ref<EntityStore> ref, @Nonnull PlayerRef playerRef, @Nonnull World world) {
    Player player = store.getComponent(ref, Player.getComponentType()); // also a component
    UUIDComponent component = store.getComponent(ref, UUIDComponent.getComponentType());
    TransformComponent transform = store.getComponent(ref, TransformComponent.getComponentType());
    player.sendMessage(Message.raw("Player#getUuid() : " + player.getUuid())); // returns UUID from UUIDComponent
    player.sendMessage(Message.raw("UUIDComponent : " + component.getUuid()));
    player.sendMessage(Message.raw("equal : " + player.getUuid().equals(component.getUuid()))); // they're both the same
    player.sendMessage(Message.raw("Transform : " + transform.getPosition()));
  }

}
```

## Adding Arguments
#### Command Argument Types
- `withRequiredArg`    // Must be provided
- `withOptionalArg`    // Returns null if not provided
- `withDefaultArg`     // Returns a default value if not provided
- `withFlagArg`        // boolean switch (--silent)

### Required Arguments
You may want your command to have arguments. To do this, you can use the `withRequiredArg` method. 

```java
public class ExampleCommand extends AbstractPlayerCommand {

  public ExampleCommand() {
    super("test", "Super test command!");
  }

  RequiredArg<String> messageArg = this.withRequiredArg("argument_name", "Argument Description", ArgTypes.STRING);

  @Override
  protected void execute(@Nonnull CommandContext commandContext, @Nonnull Store<EntityStore> store, @Nonnull Ref<EntityStore> ref, @Nonnull PlayerRef playerRef, @Nonnull World world) {

    String message = messageArg.get(commandContext); // get the argument text by the player
    player.sendMessage(Message.raw("Message Argument: " + message));
  }

}
```

### Optional Arguments

Adding a optional argument is the same, only change is the method used to create it. You can use the `withOptionalArg` method.

### ArgTypes

The following ArgTypes are available (only lists common types):

- `ArgTypes.STRING`
- `ArgTypes.INTEGER`
- `ArgTypes.BOOLEAN`
- `ArgTypes.FLOAT`
- `ArgTypes.DOUBLE`
- `ArgTypes.UUID`

## Registering the Command

For any command 

```java
public class MyPlugin extends JavaPlugin {

    @Override
    public void setup() {
        this.getCommandRegistry().registerCommand(new ExampleCommand());
    }
}
```
